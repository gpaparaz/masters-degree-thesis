\chapter{Metodologia}
\label{cap:metodologia}

% \intro{Breve introduzione al capitolo}\\

\section{Metodologia agile e EventStorming}
\label{sec:metodologia-agile}

Gli sviluppi si sono svolti seguendo la metodologia agile\footcite{site:agile-manifesto}: sono state schedulate due riunioni mensili allo scopo di tenersi aggiornati sugli sviluppi in corso, in assenza di riunioni c'è comunque stato scambio di messaggi per mantenere presente e continua la comunicazione.\\
Il principio di fondo che si è seguito è quello dello sviluppo iterativo, ovvero tenendo presente l'obiettivo finale del software si è proceduto per step implementando prima soluzioni più semplici ed immediate e poi si è proceduto nell'evoluzione di alcune funzionalità per implementare soluzioni più performanti e scalabili. \\

Le comunicazioni all'interno del team si sono basate su riunioni online, di persona e condivisione di materiale informativo per accordarci sul lavoro da svolgere.\\
Il materiale usato si è basato sulla condivisione di documenti drive e di file Figma, nello specifico parte integrante dell'attività di comunicazione è stata l'uso dell' EventStorming\footcite{womak:event-storming}.\\

\begin{figure}[!ht] 
    \centering 
    \includegraphics[width=0.9\columnwidth]{event-storming} 
    \caption{Esempio di workflow utilizzato per Epimetheus}
\end{figure}

L'EventStorming è una tecnica collaborativa utilizzata principalmente per esplorare e modellare processi complessi e sistemi software attraverso la narrazione di eventi che accadono all'interno di un sistema. È stata sviluppata da Alberto Brandolini nel 2013 ed è particolarmente utile nel contesto del \gls{domain-driven-design} (DDD). L'obiettivo principale di EventStorming è di ottenere una comprensione condivisa del dominio tra tutti i partecipanti, che può includere sviluppatori, stakeholder, esperti di dominio e altri membri del team.\\

La tecnica si basa su diverse componenti e fasi. Gli eventi rappresentano i cambiamenti di stato significativi che accadono all'interno del sistema. Vengono descritti in modo semplice, solitamente come frasi al passato, e organizzati cronologicamente lungo una linea temporale. Questo aiuta a visualizzare il flusso dei processi e a identificare eventuali lacune o incongruenze. Gli attori, che sono le persone o i sistemi che causano gli eventi, vengono collegati agli eventi che generano. I comandi sono azioni o intenzioni che provocano eventi e vengono posizionati prima degli eventi che innescano. Gli aggregati sono cluster di eventi e comandi che rappresentano unità logiche all'interno del dominio, identificati in una fase successiva per semplificare e strutturare il modello. Infine, le politiche e le regole di business influenzano come e quando gli eventi accadono.\\

Esistono diverse varianti di EventStorming, ognuna con un focus specifico. Il Big Picture EventStorming viene utilizzato per avere una visione d'insieme del dominio, coinvolgendo un gran numero di partecipanti per identificare tutti gli eventi rilevanti, i punti di interesse e le problematiche principali. Il Process Modeling EventStorming si concentra su specifici processi o flussi all'interno del dominio, modellando con precisione come funzionano. Il Design-Level EventStorming è impiegato per progettare soluzioni tecniche specifiche, coinvolgendo principalmente sviluppatori e concentrandosi su come implementare gli eventi e i comandi nel codice.\\

L'EventStorming offre numerosi benefici. Favorisce la collaborazione tra tutti i partecipanti, aiutando a costruire una comprensione comune del dominio, permette di visualizzare facilmente le aree del sistema che potrebbero essere poco chiare o incomplete, coinvolgendo direttamente gli esperti di dominio per garantire che il sistema rifletta accuratamente la realtà del business, inoltre, la natura visiva e interattiva dell'EventStorming lo rende un metodo rapido e flessibile per esplorare e modellare domini complessi rispetto ai metodi tradizionali di documentazione.\\

La metodologia nello sviluppo software ha visto l'utilizzo di un approccio \textit{top-down}, ovvero sono partita prima da una visione d'insieme delle interazioni tra le parti, e successivamente mi sono concentrata sui dettagli. Questo approccio implica partire dal livello più alto di astrazione e suddividere il sistema in componenti sempre più piccoli e specifici. \\
Le caratteristiche dell'approccio top-down prevedono una definizione chiara degli obiettivi e delle funzionalità globali di sistema, dove viene creata una visione d'insieme che descrive il istema nel suo complesos, includendo le sue principali componenti e interazioni. Successivamente vi è la decomposizione, ovvero il sistema viene suddiviso in sottoinsieme più piccoli dove ogni modulo rappresenta una parte specifica della funzionalità complessiva del sistema. Ogni modulo viene quindi progressivamente raffinato, accompagnandolo da ulteriore documentazione e/o pianficazione. \\
I vantaggi dell'approddio top-down sono chiarezza e coerenza, migliore gestione della complessità in quanto suddividere il sistema in componenti più piccoli permette una migliore gestione del progetto e della sua complessità, ed infine maggiore facilità di manutenzione. Lo svantaggio è che richiede maggiori tempi di sviluppo in quanto parte del tempo è impiegato per la progettazione, e se dovesse esserci un errore nella visione globale questo si ripercuote su tutto il progetto. In questo caso avere costanti interazioni con i vari soggetti coinvolti nello sviluppo di Epimetheus ha permesso di limitare gli errori di visione.\\

Per quanto riguarda la collaborazione tra sviluppatori ci siamo avvalsi dell'uso di \textbf{Git}, un sistema di controllo di versione che ci ha permesso di tracciare le modifiche e di lavorare in contemporanea sul progetto. La separazione del frontend dal backend è stata operata su un branch separato rispetto a quello iniziale, mentre l'utilizzo di questo sistema di versionamento ci ha permesso di tornare indietro quando necessario.

% \section{Sviluppo iterativo}
% \label{sec:sviluppo-iterativo}

% Di seguito viene data una panoramica delle tecnologie e strumenti utilizzati.

% \subsection*{Tecnologia 1}
% Descrizione Tecnologia 1.

% \subsection*{Tecnologia 2}
% Descrizione Tecnologia 2

% \section{Ciclo di vita del software}
% \label{sec:ciclo-vita-software}

% \section{Progettazione}
% \label{sec:progettazione}

% \subsubsection{Namespace 1} %**************************
% Descrizione namespace 1.

% \begin{namespacedesc}
%     \classdesc{Classe 1}{Descrizione classe 1}
%     \classdesc{Classe 2}{Descrizione classe 2}
% \end{namespacedesc}


% \section{Design Pattern utilizzati}

% \section{Codifica}
